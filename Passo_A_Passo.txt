1. CRIAR AS CLASSES MODELS E SUAS PROPRIEDADES

2 . NO PROJETO SERVER ADD Microsoft.EntityFrameworkCore.sqlserver e
Microsoft.EntityFrameworkCore.tools

3. No projeto server add pasta context criar classe appdbcontext que herda de DbContext. Essa classe é usada para comunicar com banco de dados.
 	 3.1 - nessa classe adicionar um construtor
	''''''public AppDbContext (DbContextOptions<AppDbContext> options) : base(options){}''''''
 	3.2 -  Adicionar propriedades DbSet na classe a quantidade é igual a quantidade de classes no models(tabelas)
			''''''''''''     public DbSet<Categoria> Categoria { get; set; }
        public DbSet<Produto> Produtos { get; set; } ''''''''''''''' 
		Lembrando que  as models  precisam ser public


4. Definir  banco: Então precisa criar um aquivo json contendo a string de conexão. 
{
  "ConnectionStrings": {
    "DefaultConnection": "string de conexão"
  }
}

5. Criar um construtor na classe startup 
   '''''''''''''private readonly IConfiguration configuration;
        public Startup(IConfiguration configuration)
        {
            Configuration = configuration;
        }''''''''''''''
6. adicionar no metodo ConfigureServices o codigo para conectar no banco:
  '''''''' services.AddDbContext<AppDbContext>(options =>
            options.UseSqlServer(configuration.GetConnectionString("DefaultConnection")));'''''''''''

7.aplicar os atributos nas propriedades do model. precisa incluir um pacote system.componentModel.Annotations no shared
  [MaxLength(100)]
8. FAZER O MIGRATION.  add-migration inicial_1 e depos database-update
9.no projeto server na pasta controoler adicionar os controlers.
	9.1 selecionar api controller empty e adicione um controoler para o model desejado
	9.2 depois na classe criada adicione um constutor para fazer a injeção de dependencia da 		classe do banco, context: 
 		''''''''  private readonly AppDbContext context;
       		 public CategoriaController(AppDbContext context)
        				{     this.context = context;   }
	9.3 depois de fazer a injeção da dependecia é possivel usar o banco.

	9.4 o primeiro metodo retorna todas as categorias: 
   	''''''''''''''''[HttpGet]
        public async Task <ActionResult<List<Categoria>>> Get()
        {
            return await context.Categoria.AsNoTracking().ToListAsync();
            //asnotracking desabilita o rastreamento das entidades e obtem um desempenho melhor
        }''''''''''''''''''''''''

	9.5 o metodo para retornar apenas uma categoria
	'''''''''''''' [HttpGet("{id}",Name ="GetCategoria")]
        public async Task<ActionResult<Categoria>> Get(int id)
        {return await context.Categoria.FirstOrDefaultAsync(x => x.CategoriaId ==id);}'''''''''
	
	9.6 metodo para cirar uma categoria
	''''''''''    public async Task<ActionResult<Categoria>> Post (Categoria categoria)
        {
            context.Add(categoria);
            await context.SaveChangesAsync();
            return new CreatedAtRouteResult("GetCategoria",
                new { id = categoria.CategoriaId }, categoria);
        }'''''''''''
	9.7 metodo para alterar categoria
      '''''''''''[HttpPut]
        public async Task<ActionResult<Categoria>> Put (Categoria categoria)
        {
            context.Entry(categoria).State = EntityState.Modified;
            await context.SaveChangesAsync();
            return Ok(categoria);
        }'''''''
	9.8 metodo para deletar uma categoria
       [HttpDelete]
        '''''''public async Task<ActionResult<Categoria>>Delete (int id)
        {
            var categoria = new Categoria { CategoriaId = id };
            context.Remove(categoria);
            await context.SaveChangesAsync();
            return Ok(categoria);
        }'''''''





